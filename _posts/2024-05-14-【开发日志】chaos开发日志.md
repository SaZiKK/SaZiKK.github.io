---
comments: true
title: 【开发日志】chaos开发日志
Author: SaZiKK
categories:
  - OS
  - develop
date modify:  2024-06-30 02:05:49 +0800
date: 2024-05-14 16:29:17 +0800
tags:
  - os
  - competition
date create:  2024-05-14 16:29:17 +0800
---
这是2024系统能力大赛操作系统内核赛道作品chaos开发日志，本项目基于~~ArceOS~~ rCore开发。
### 2024.5.14
结束前置学习，克隆项目，配置工作区。

### 2024.5.20
基本了解ArceOS思想及架构，进行初步更改。

#### ArceOS基本架构思想
ArceOS最大的特点就是组件化开发，它把系统内核的功能拆分为了系统有关和系统无关，也就是不可移植和可移植的区别。不可移植的模块叫module，命名以ax开头；可移植的模块叫crate，与内核只通过接口交流。

#### ArceOS实现全流程syscall过程
要想明白应该如何在ArceOS的架构中实现一个syscall，最好的方式就是从用户出发，从用户的syscall请求开始回溯。

在ArceOS中，用户直接面对的是来自用户库`ulib`的接口，用户只需要直接调用其中接口即可，在调用的同时，用户也要对应的启用一定的`feature`，这也是ArceOS的特色之一，我们先按下不表。深入`ulib`，仔细参考接口的实现后，可以发现接口都是对于`arceos_api`中方法的封装，正如其名字所说的那样，`arceos_api`提供了一系列面向用户库的接口，如最基础的`ax_console_read_byte`等。这里可以看到ArceOS的代码规范非常好，所有mod和lib文件都是非常干净的接口引用，没有添加任何功能代码的实现。

再进入`arceos_api`，我们就可以看到这里的方法来自各个module，同时我们熟悉的`sys_*`函数也分布在这里。实现过syscall的朋友们都知道（迫真），到这里就是一个`原子syscall`（我自己瞎取的名），即所有内核功能在这里首次被打包成一个完整syscall，再进行层层封装。

了解了syscall的调用流程，想要实现一个syscall也就简单了，具体syscall过程中，特权级的切换，上下文的保存等我还没有深究，还要继续研究，但是中断实现上应该都大差不差。

需要注意的是syscall的具体实现方法。ArceOS为我们实现了一个奇妙的宏`syscall_body`，我们需要传入syscall_id等参数，对于参数的主要操作也就是syscall的主要部分都在里面完成，宏如其名了属于是。

### 2024.5.23

淦，ArceOS看不下去了，转投rCore

#### 修改测试逻辑和用例
修改`Makefile`，让chaos可以运行初赛测例，同时基本删除原有的应用，只保留`shell`和`initproc`，再自定义了一个应用用于一键执行所有应用。

基本思路就是把编译好的elf初赛测例也和rust应用的elf文件塞到一起然后一起加载，rCore原有的流程扩展性不强，因此花了不少时间改。

#### 新建dev分支开发syscall

新维护了一个dev分支，同时队友大改文件系统，分了一个feat分支出去。

感觉换成rCore之后前途一片光明（完犊紫）啊。

### 2024.5.24

#### 实现`SYS_times`
统计一下进程的内核和用户态clock时间，之前写过，没什么难度。大致可以参考rCore的习题`扩展内核，统计每个应用完成时间`。

#### 修改测例顺序
王老板在参考linux源码重构文件系统，暂时不处理文件系统相关syscall，把文件系统相关syscall放到了后面。

#### 实现`SYS_uname`
只是输出固定字符串而已，非常简单，但是一定一定要注意在我们内核内部，u8数组的长度要和riscv标准下的`utsname`结构体的成员字符数组长度保持一致，都是65字节，长度不一致就会导致切片复制时出错。

### 2024.5.25

#### （4:38 am）实现`SYS_wait4`
只需要修复rCore的`sys_waitpid`方法即可。

这里踩了不少雷。首先是需要搞清楚对于`SYS_wait4`的调用函数看似很多而且各不相同，实际上都是`SYS_wait4`通过封装派生出来的，因此安安稳稳实现就行。

其次是`WEXITSTATUS`宏的问题。`WEXITSTATUS`宏名义上会取`wstatus`的低8位，作为子进程的退出状态，但是阅读其源码会发现，所谓低8位指的是小端法下的低8位！鬼知道为什么这里会出现小端！！因此在赋值的时候我们需要把传进去的`exit_code`左移8位来保证其存储在小端上（这里就偷懒不交换两端而是直接左移了），这样才能正确解析出退出状态值，通过测例。参考往届的代码也没有在这里做特殊处理，暂时不知道他怎么过的测例，猜测是FAT32文件系统发力了，而我们尚未实现FAT32，王老板还在猛肝。

#### （7:24 am）实现`SYS_brk`
要实现`SYS_brk`，首先要支持堆的操作。我为地址空间memory_set新增维护了其对应的堆空间，地址即为elf文件中读到的地址，这个地址原本被用作user_stack_top，即用户栈顶，然后将用户栈顶放置到一个固定地址0x100000000，最后再把`UserTaskRes`维护的的用户栈底`ustack_base`改为用户栈顶`ustack_top`，维护相关方法。妥善维护上面所有修改之后就可以动手实现syscall了，具体的实现参考了往届的学长，按照传入地址修改堆区末尾指针位置在再修改映射即可。

#### 实现`SYS_nanosleep`
设置一个预计时间，反复循环忙等待到时间到达即可，期间进程直接yield。（或许应该block？）

#### 维护了阻塞队列`block_queue`
还未实现具体应用。

#### 实现`SYS_getppid`
过于简单，不做赘述。

### 2024.5.26

#### 完成FAT32文件系统
王老板写完了FAT32，分支merge进了dev。王老板牛逼。

#### 修复`LoadPageFault`的问题
加入文件系统之后遇到了严重的错误，所有的应用都能正常读取，但是全部报`LoadPageFault`，非法的地址是用户栈顶。debug了一整天后认为和文件系统和内存管理都无关，最后发现是分配的用户栈没有没有左闭右开，然后读取右边的栈顶就炸了，但是原来的rCore没有维护这个问题。进一步思考后发现应该是因为引入文件系统镜像之后取消了初始进程`initproc`，由他`fork`出的进程用户栈地址空间都合法的维护了，而取消了初始进程之后，所有应用申请的用户栈地址空间读取右边就会非法，因为他们都变成了0号进程。

至于为什么初始进程作为0号进程可以正常运行，我们认为是初始进程使用了`no_main`feature，这样他在启动的时候就不会首先读取用户栈顶获取`main`函数的参数。目前的解决办法是暂时给用户栈顶 -4 ，等完成了所有syscall之后再修复。具体的修复方案暂定是额外打包一个包含了初始进程的镜像一起上传。

### 2024.5.28

#### 实现`SYS_clone`
`SYS_clone`我调了足足两天，问题来自于参数的不匹配以及参考资料的稀少。en读了Linux源码和测例提供的部分glibc之后选择单独为测例实现一个`fork2`，即创建新进程，且执行自定义函数。测例提供的lib很关键，因为测例的lib是经过魔改的，`clone`函数的实现被替换成了自定义的汇编函数，阅读汇编代码可知，需要运行的函数指针并不会直接传给内核，而是会把它和函数参数一起压栈，再把栈指针传入内核，因此只需要把子进程中断上下文中保存的栈指针替换成传入的栈指针即可实现执行指定的函数。

#### 修复`SYS_execve`
加文件系统后会`StorePageFault`，猜测是内核栈爆了，开了两倍的内核栈成功修好。

#### 实现`SYS_fstat`
`SYS_fstat`在rCore-lab期间已经完成，只是`Stat`结构体的内容不同，因此修改结构体，维护一下内容即可。因为测例没有要求，目前仅维护了文件大小。

#### 重构`SYS_mmap`
之前的`SYS_mmap`过于原始，耦合度高且映射方式存在问题，因此给予重构。

首先是映射位置需要再修改，对于`flag`没有指明是`FIXED`的映射，我们不需要按照传入的虚拟地址直接映射，而是应该指定一个地址用于匿名映射，并以这个地址为基准进行映射。为此我们规定`MMAP_BASE`为0x20000000，然后为每个地址空间维护`mmap_base`和`mmap_end`，用于管理映射。对于指定了`FIXED`的映射，我们按照之前那样直接映射。

其次是文件映射，`SYS_mmap`要求能够实现文件映射，也就是在映射一块空间的同时把指定文件的数据初始化在这段内存中，`copy_from_slice`一下即可。

#### 实现`SYS_munmap`
`SYS_mmap`改了，`SYS_munmap`当然也要改。取消映射就简单多了，修改`mmap_end`再unmap一下就行。

### 2024.5.29（凌晨）

#### 比赛环境配置

到这里，所有的`syscall`都实现了，接下来就是配置环境尝试提交。

首先要做的是把所有外部包改为本地编译，因为测评机不联网。统一放进一个`vendor`文件夹管理即可。
然后是修改一下`Makefile`，满足测评要求的同时维护一下`.cargo`，因为测评机`clone`项目时会忽略隐藏文件夹，需要交上去再在`make`的时候改名。
最后我们要在`rust-toolchain`里指定`building targets`，并且在`cargo.toml`里添加`rustflags = ["-Zbuild-std=core,alloc"]`，确保编译时包含`core`库。
这样我们提交后就可以成功得到成绩（~~已经寄了7发了~~）

## **通过初赛！**
小修两个bug，9发提交满分通过，排名14

---

### 2024.6.19 开始重构
摆了一段时间开始计划重构代码，首先的目标是取消rCore的双页表机制，双页表虽然可以防侧信道攻击，但是带来的性能开销也很大，与我们的目标不符。

取消双页表也是为下一步进一步实现无栈协程做铺垫，修改为内核态用户态共用页表之后就可以按照无栈协程的一般处理方式，让进程共用内核栈。

### 2024.6.23

#### 修改内核地址空间
为了让内核态核用户态共用一张页表，我们需要对地址空间进行适当分割。这里我们直接利用 SV39 的机制：64 位虚拟地址只有低 39 位有效，[63 : 39] 这 25 位必须和第 38 位相同，即对于 SV39 机制来说，有效的地址范围为 `0x0000000000000000` - `0x0000003fffffffff` 和 `0xffffffc000000000` - `0xffffffffffffffff`，这恰好分成两份，还能根据符号位（作为补码看）轻易辨别地址属于哪个区间。因此我们把用户地址空间映射到`0x0000000000000000` - `0x0000003fffffffff`，把内核地址空间映射到`0xffffffc000000000` - `0xffffffffffffffff`。

我们首先修改链接脚本，把内核代码映射到 `0xffffffc080200000`，因为目前编译出的elf并不是位置无关的，而 rustsbi 默认跳转的位置是 `0x80200000`，那怎么在能在启动的时候迅速把内核代码映射到高位呢，我们需要在启动时手写一个简单的页表，修改 `satp` 寄存器。

手写个三级页表显然太炸裂了，因此我们利用大页机制，只映射两个 1G 大页，也就是只使用一级页表，MMU 查到有效页表项就会自动停止。将 `0x8000_0000` 和 `0xffff_ffc0_8000_0000` 两个大页添加到页表项即可。

```Assembly
boot_pagetable:
    # we need 2 pte here
    # 0x0000_0000_8000_0000 -> 0x0000_0000_8000_0000
    # 0xffff_fc00_8000_0000 -> 0x0000_0000_8000_0000
    .quad 0
    .quad 0
    .quad (0x80000 << 10) | 0xcf # VRWXAD
    .zero 8 * 255
    .quad (0x80000 << 10) | 0xcf # VRWXAD
    .zero 8 * 253
```

经过修改后内核可以正常启动进入，证明了映射的处理正确，当然内存管理经过修改显然存在严重问题，有待进一步修改。

仍然存在的疑问：为什么也需要映射用户态地址空间，进入内核时不是应该保持在高位运行吗

#### 实现自旋锁，添加锁支持
一个多核操作系统会需要一套完善的锁机制，由于锁模块与内核相对隔离，且使用较多，优先实现一部分锁的内容。首先我对代码架构进行了一定更新，然后添加了 `MutexSupport` ，用来为自旋锁、互斥锁等简单锁提供支持，随后实现了基础的自旋锁。接下来还会需要大幅重构锁机制的代码，逐步替换原先的锁，使它结构上更加独立，形成一个独立的锁模块。这里很大程度上参考了 Titanix 的实现和文档。

```rust
/// Low-level support for mutex(spinlock, sleeplock, etc)
pub trait MutexSupport {
    /// Guard data
    type GuardData;
    /// Called before lock() & try_lock()
    fn before_lock() -> Self::GuardData;
    /// Called when MutexGuard dropping
    fn after_unlock(_: &mut Self::GuardData);
}
```

#### 移除信号量和条件变量机制
为了实现无栈携程，我们计划提供 futex 给用户使用，并取代信号量机制，同时，我们实现了 `SpinNoIrqLock` 给内核提供锁服务。因此，我移除了所有的信号量机制以及条件变量，并将 rCore 原本的自旋锁替换为了新架构的关中断的自旋锁。这一步没有实现什么新的功能，主要是在重构代码，并使其逐步适应无栈携程的需要。

### 2024.6.29
#### 虚拟地址与链接脚本不一致
修改了链接脚本的内核基址并且在内核入口中手写页表之后，通过内核映射前打印出的数据可知，内核的各个段还是被映射到了页表中的低地址，与链接脚本不符。这里我思考了我们是如何从链接脚本中获取代码段地址的，我认为函数名、汇编符号、函数代码入口地址这三者是同一回事（假设函数名未被混淆，实际上C++和Rust都会混淆，C不会），我们通过 `extern "C"` 引入外部C函数实际引入的是函数符号，也就是函数入口地址，因此我们就可以在Rust里调用C函数，同样，我们也可以用相同的方式获取某个符号的地址。这里我们直接在链接脚本中规定了各个代码段以及具体符号的位置，链接脚本直接指导链接器，也就绕过了编译器可能的混淆，保留了符号的原本名称，我们就可以通过 `extern "C"` 将其引入，从而得到了各个代码段的具体地址

经过一段时间（3个小时）的排查，我们发现虽然符号表中各个符号确实处于地址空间高位，但是代码段实际位置与符号表不符，仍然位于低地址空间。由于低地址空间和高地址空间完全对称，内核虚拟地址也只需要减去偏移量（`0xffffffc000000000`）就是物理地址，所以我们可以在进入主函数 `rust_main` 之前，将跳转目标加上偏移量，使后续的代码在高地址空间执行，由于所有的跳转都被编译为相对 pc 跳转，因此不影响程序的正确性。

```rust
#[no_mangle]
pub fn fake_main() {
    unsafe {
        asm!("add sp, sp, {}", in(reg) KERNEL_SPACE_OFFSET << 12);
        asm!("la t0, rust_main");
        asm!("add t0, t0, {}", in(reg) KERNEL_SPACE_OFFSET << 12);
        asm!("jalr zero, 0(t0)");
    }
}
```

修改后获取的虚拟地址与符号表匹配了，但是创建新地址空间时卡死，使用gdb调试还会导致内核无限循环。通过检查又长又臭的 qemu log 发现，在访存内核代码段末尾，也就是ekernel时出现异常，而异常处理函数的位置，也就是 `stvec` 寄存器，被默认指向了内核开头 `0x80200000` ，这就是出现循环的原因。进一步检查代码发现 rCore 原生的地址转换逻辑有误，因为原先并没有考虑传入虚拟地址可能位于地址空间高位的情况，因此取物理地址时忽略了高8位，导致取出的地址不合法，重构地址转换逻辑即可解决。

### Todos：
- [x] 继续实现syscall
- [ ] 彻底实现block queue
- [x] fork时复制mmap区域
- [ ] 为waitpid启用block机制
- [ ] 添加初始进程，修复用户栈顶问题
- [ ] 完整实现clone、execve
- [ ] 补充实现Mutex
- [ ] 重构代码
  - [ ] 重构锁结构 half way done
  - [ ] 重构utils 
- [ ] 无栈异步协程调度
- [ ] 内核态中断
- [ ] 内核态用户态共用页表
  - [x] 修改内核入口，实现启动时映射
  - [ ] 检查用户态传入地址
- [ ] 实现多核
- [ ] 页缓存
- [ ] inode缓存
- [ ] 写时复制
- [ ] 共享页映射
- [ ] Lazy分配
- [ ] mmap内存拷贝优化
- [ ] 

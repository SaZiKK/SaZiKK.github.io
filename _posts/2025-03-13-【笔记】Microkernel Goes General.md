---
title: 【笔记】论文阅读笔记-Microkernel Goes General
Author: SaZiKK
categories:
  - Papers
tags:
  - os
comments: true
excerpt: "2024 OSDI 论文阅读笔记-Microkernel Goes General: Performance and Compatibility in the HongMeng Production Microkernel"
---

打完比赛后一直对鸿蒙和微内核架构很感兴趣，于是抽出时间阅读了这篇论文。

### 文章概述：

本文介绍了鸿蒙微内核架构的设计和实现，重点描述了传统微内核的性能瓶颈以及鸿蒙针对性的优化方式。

### 背景

移动设备系统、嵌入式系统以及车载系统等新兴场景需要内核拥有更好的安全性、可扩展性和性能，以 linux 为代表的宏内核并不擅长这些场景，**微内核**在这些方面拥有显著的架构优势，但主流的微内核架构在**性能和兼容性**上存在很多问题。

#### 问题一：软件生态

在特定领域的场景中，应用程序往往是定制化的，因此符合 posix 标准被认为足以兼容应用，但在以智能手机为代表的新兴场景中，很多应用和库以二进制形式分发，仅仅满足 posix 标准并不足以兼容，还要求 Linux ABI 兼容性。

#### 问题二：资源管理
在特定领域的场景中，应用程序较少，硬件资源优先，所以内核往往负责预留资源，应用程序自己管理，但在新兴场景中，多个应用程序竞争资源，因此需要内核有更完善的资源管理机制，实现高效而公平的资源管理和分配。

#### 问题三：性能

在特定领域的场景中，微内核优先考虑安全性和严格的资源隔离，并主要用于静态应用程序，性能不是关键点，但在新兴场景中，性能也是重中之重，因为性能直接决定用户体验并籍此影响内核的广泛部署。尽管 SOTA 微内核如 sel4 已经实现了破纪录的高 IPC 性能，但是他们仍会因为高频率的 IPC 、多服务端设计导致的状态双重簿记、基于能力的访问控制等问题造成不小的性能开销。

#### linux 的问题：

1. 安全可靠性不足。其文件系统和大量驱动贡献了大量 CVE 漏洞，并且其中 80% 的漏洞都可以通过正确的隔离解决，而且由于 linux 代码固有的紧密耦合，很难对其进行优化和重构。同时，内核模块的不稳定也导致了频繁的升级，使内核在实际部署中不太实用
2. 通用和专业化的冲突。linux 的目标是通用化，然而最新的 patch 在向服务器和云倾斜，甚至影响到了部分其他场景。同时，快速增长的各种设备需要专门的策略来保证性能和能耗，而对于 linux 进行针对性优化不仅需要消耗巨量人力，还很难并入内核主线。
3. 定制化和内核更新的冲突。定制化的内核和内核主线同步需要花费大量努力，而 linux 频繁更新的内核 API 更是阻碍了同步，这导致了实际部署内核时的内核定制化非常困难。因此，市面上大量产品仍在使用 linux 2.6，其生命周期早已结束。

### 针对问题的观察

由于鸿蒙早已广泛部署商用，所以收集了很多如手机、路由器、汽车等具有代表性的场景下的运行数据。

![Characteristics](../assets/figures/papers/micro-kernel/f1.png)

#### 观察一：新兴场景中 IPC 频率快速增加

当所有 OS 服务被限制在用户地址空间时，部分新兴场景下的 IPC 频率如图（1a）所示，智能手机（平均 41k/s）和车辆（平均 7k/s）的 IPC 频率远高于路由器（平均 0.6k/s，更接近领域特定场景），而从图（1b）（1e）（1f）中可以看出，更高的 IPC 频率不仅仅是因为更高的 syscall 频率（61k/s，路由器的 13 倍），还因为大量的文件操作（与文件系统的 IPC），以及在映射在内存上的文件上触发了大量的 page fault，这需要内存管理器和文件系统之间的大量 IPC。

**结论**：相比起提高 IPC 性能，减少 IPC 频率也很重要。

![flame_graph](../assets/figures/papers/micro-kernel/flame_graph.png)

#### 观察二：分布式多服务端导致状态双重簿记

在传统的宏内核设计中，所有服务包括文件系统、内存管理都在内核空间，页缓存、文件描述符等信息都作为全局变量由内核统一管理，仅需要维护一份；但在微内核架构的分布式多服务端设计中，文件系统服务和内存管理服务是隔离的，他们各自需要一份页缓存来加速文件访问/管理内存映射，并且两个服务都需要记录文件描述符，这就是状态双重簿记（state double bookkeeping）

微内核设计的最小化准则决定了共享资源（比如 fd 和页缓存）没有被集中化管理而是分布式存放，但是如图（1c）（1d）（1e）所示，新兴场景下的应用程序经常调用 poll 等函数，这些函数较为依赖对于这些共享资源的集中管理。图 2 进一步展示了应用程序启动的 CPU 火焰图，这对于文件映射的性能依赖很大，同时也对用户体验至关重要。如图所示， 16% 的时间倍用来处理页缓存未命中，比 linux 慢一倍，且状态双重簿记在文件系统和内存已经消耗了 120MB 的基础上额外消耗了 50MB 的内存。

#### 观察三：基于能力的访问控制阻碍了高效合作

基于能力的访问控制将内核对象隐藏在不同能力后面，这导致了某些内核对象的频繁更新（比如页表）从而引入了显著的性能开销，并阻碍了他们之间的高效合作，比如这可能会导致匿名页错误的处理比 linux 慢 3.4 倍，这种情况在智能手机中尤为常见（平均 27k/s，占图（1b）中的小型 page fault 的 80%），并且给应用程序增加了不小的启动开销时间（图 2 中的 4%）。

#### 观察四：生态兼容性要求不仅仅是符合 POSIX 标准

许多 SOTA 微内核通过使用自定义运行时库来实现 POSIX 合规的最小子集，这些库直接链接到应用长须，并生成 IPC 到系统服务，但是这样面临着二进制不兼容的问题以及需要一个自定义构建环境。此外，因为 Linux 使用文件作为统一的接口，而微内核内没有这样的接口，实现高效的 fd 复用以及向 ioctl 这样的向量系统调用变得很有挑战性，而这些系统调用在新兴场景非常常用（如图（1c-1e））

#### 观察五：新兴场景部署需要高效的驱动复用

在智能手机上部署鸿蒙时，我们发现所需的驱动数量大幅增加，对于路由器，所需的驱动少于 20 个，但是对于智能手机和车辆，则需要超过 700 个。我们估计重写这些驱动需要花费 5000 人/年，并且需要时间持续成熟和演化。所以，重用驱动是一个更明智的选择。然而，之前的工作，包括一直驱动的运行时环境和使用虚拟机等，面临着兼容性、工作量和性能方面的挑战。

### 鸿蒙的宏观设计

鸿蒙的设计总体上尊重微内核的设计准则，但是没有极端的追求而是做出了一些取舍。

![design](../assets/figures/papers/micro-kernel/design.png)

![overview](../assets/figures/papers/micro-kernel/overview.png)

#### 原则一：保持最小化

微内核的安全、可靠、可扩展来自于三个基本的架构设计原则：

1. **分离策略（Policy）和机制（Mechanism）**。内核仅提供基本的机制，具体策略由用户态服务实现。
2. **解耦和隔离系统服务**。把 OS 服务分解为独立组件，服务之间严格隔离并降低互相依赖。
3. **细粒度的访问控制**。遵循最小权限原则，严格控制资源访问权限。

鸿蒙只**在核心内核中保留最小和必要的功能**，包括线程调度器、串口和定时器的驱动以及访问控制器，其他所有功能都被限制在**隔离的操作系统服务**中，比如进程/内存管理，驱动和文件系统。同时，鸿蒙采用了**细粒度的访问控制**以保持最小权限原则

**保留：拥有良好隔离的系统服务并保持最小权限原则的最小化微内核**

#### 原则二：性能优先

微内核在新兴场景中的巨大优势被架构固有的性能问题所损害。因此鸿蒙**没有强制执行严格而统一的隔离，而是提供结构上的支持来组装系统**，以满足性能和安全需求。同时，鸿蒙除了**采用类似 RPC 的快速路径来解决资源分配/耗尽/簿记问题**，还提出了**差异化的隔离类**，通过放宽受信任操作系统服务之间的隔离来减少 IPC 开销。鸿蒙还**将紧密耦合的操作系统服务整合在一起**（图三中的❶），以尽可能降低 IPC 频率。此外，鸿蒙**使用地址令牌（token）补充能力**，实现高效的内核对象共同管理（图三中的❷），从而加速**对匿名内存的无策略内核分页**（policy-free kernel paging of anonymous memory）。

**灵活：通过提供结构性支持以实现灵活组装，适应多样化场景，从而优先考虑性能**

#### 原则三：最大化生态兼容性

鸿蒙通过一个 shim（图三中的❸） 层来实现与现有软件生态的兼容，确保 **Linux ABI 兼容性**，这个 shim 层把所有 Linux syscall 重定向到适当的操作系统服务，并作为一个中心储存库来存储和翻译 Linux 系统抽象（比如 fd），从而高效支持 poll 等功能。此外，鸿蒙通过**驱动程序容器**（图三中的❹）提供一个从 Linux 主线派生的运行环境来复用原版的 Linux 设备驱动，这样所需的工作量较少。鸿蒙还进一步利用**分离控制层和数据层**来提高驱动程序的性能（图三中的❺）。

**增强：通过实现 Linux API/ABI 兼容和高性能的驱动程序复用来最大限度地提高兼容性。**

### 鸿蒙的威胁模型

鸿蒙为了防止恶意应用程序和操作系统服务访问彼此的内存，并确保数据的机密性、完整性和可用性（CIA），维持了类似于现有微内核的威胁模型，但有以下不同：

#### 集中式内存管理

由于新兴场景中的应用程序出于兼容性原因需要集中式内存管理，内存管理器和它整合的服务（在部署的手机上只有文件系统）会不可避免的访问应用程序的地址空间。此外，在内存由自身管理的安全关键场景中，鸿蒙就不会创建这样的集中式内存管理器。

#### 部分妥协

出于性能考虑，存在对一些额外的攻击面、故障域的划分以及额外的数据泄露可能性（只存在于精心选择的对象）的妥协。

### 鸿蒙的性能设计

![IPCcompare](../assets/figures/papers/micro-kernel/IPCcompare.png)

#### 同步的类 RPC 式 IPC 快速路径

**同步还是异步 IPC**

IPC 通常假设两端对称，也就是拥有相同执行模型。因此以往的研究提议异步 IPC 可以避免多核上的串行化，允许双方都能不阻塞的运行。然而，在新兴场景中，鸿蒙团队观察到大多数 IPC 都是过程调用，可以清楚识别调用方和被调用方。此外，操作系统服务主要是被动调用的而不是连续工作的，并且应用程序后续的操作大多依赖于过程调用的结果（也就是不能异步）。因此，同步远程过程调用（RPC Remote Procedure Call）是服务调用更适合的抽象。

鸿蒙采用类似 RPC 的线程迁移作为服务调用的 IPC 快速路径。当发送 IPC 时，核心内核执行直接切换（绕过调度），只切换栈指针和指令指针（避免切换其他寄存器）以及保护域。具体地说，鸿蒙要求操作系统服务注册一个处理函数作为入口点，并准备一个执行堆栈池。当应用程序调用服务时，核心内核在一个调用堆栈中记录调用者的栈指针和指令指针，并切换到处理函数和准备好的执行栈。在返回时，鸿蒙从调用堆栈里 pop 出 entry 并跳转回调用者。 IPC 的参数主要由寄存器传递，附加参数通过共享内存传递。

虽然鸿蒙绕过了调度并避免切换寄存器，但是由于权限级别/地址空间切换和缓存/TLB污染（占总 IPC 成本的 50%），仍然面临着显著的性能下降。鸿蒙团队使用差异化隔离类进一步弥补了这一性能差距。

**资源分配**

大部分之前的工作都忽视了 IPC 的内存占用。然而，由于智能手机等新兴场景中的极高频 IPC 和海量的连接数（同一时间 >1k 线程），鸿蒙团队发现在生产中考虑 IPC 内存占用非常重要，因为它可能会导致严重的问题，比如 OOM 甚至系统挂起。尽管鸿蒙的每个 IPC 连接仅需要一个单独的执行栈（而不是一个具有所有相关数据结构的成熟线程），但考虑搭配巨量的 IPC ，其内存占用仍然不小。

传统的做法是预分配固定大小的线程/栈池并绑定到各个连接，但是固定的大小很难确定，因为工作负载多样而且动态变化，比如不同 OS 服务的需求不同，运行的线程数量也在变化。一个大池会迅速耗尽内存，而动态分配则会在 IPC 关键路径上引入运行时开销。鸿蒙团队尝试过在线程创建的时候为每个 OS 服务创建并绑定堆栈，但是他们很快发现一些服务几乎不被某些线程使用造成浪费，并且存在一些到另一个 OS 服务的 IPC 链需要另一个堆栈。（最后一句没看懂）

因此，鸿蒙通过**为每个线程预绑定常用的 OS 服务（进程/内存管理和 fs）中的堆栈**，并同时维护一个大小在运行时自适应的堆栈池，从而找到了一个折中点。当剩余堆栈大小低于阈值时，OS 服务将分配更多堆栈以减少同步分配。鸿蒙还通过在 IPC 链调用同一个 OS 服务时重用堆栈来进一步减少了内存占用。

不是很懂这里的 OS 服务中的堆栈是什么。

**资源耗尽**

由于资源耗尽，IPC 是可能会失败的。具体来说，当堆栈池耗尽也就是出现 OOM 的时候，OS 服务无法分配新的堆栈处理 IPC 请求，而且应用程序无法处理这种问题（因为在宏内核中不存在 syscall 无法处理的情况）。因此，在 SOTA 微内核中，这类请求会被排队（阻塞），这可能导致严重的问题，比如循环等待死锁甚至系统挂起。

一种直观的想法是向内存管理器发送一个 IPC 回收内存，但是在这种已经 OOM 的情况下这个 IPC 也可能会失败。这种情况可能发生在作负载不确定且频繁发生重负载的新兴场景中（例如，手机同时打开多个应用程序）。

鸿蒙通过保留一个专门的堆栈池来解决这种问题，当 OOM 的时候，内核会使用这个堆栈池同步 IPC 到内存管理器进行内存回收，直到用户的 IPC 成功。（这何尝不是一种水多加面面多加水（）


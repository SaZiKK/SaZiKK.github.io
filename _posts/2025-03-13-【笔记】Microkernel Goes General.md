---
title: 【笔记】论文阅读笔记-Microkernel Goes General
Author: SaZiKK
categories:
  - Papers
tags:
  - os
comments: true
excerpt: "2024 OSDI 论文阅读笔记-Microkernel Goes General: Performance and Compatibility in the HongMeng Production Microkernel"
---

打完比赛后一直对鸿蒙和微内核架构很感兴趣，于是抽出时间阅读了这篇论文。

### 文章概述：

本文介绍了鸿蒙微内核架构的设计和实现，重点描述了传统微内核的性能瓶颈以及鸿蒙针对性的优化方式。

### 背景

移动设备系统、嵌入式系统以及车载系统等新兴场景需要内核拥有更好的安全性、可扩展性和性能，以 linux 为代表的宏内核并不擅长这些场景，**微内核**在这些方面拥有显著的架构优势，但主流的微内核架构在**性能和兼容性**上存在很多问题。

#### 问题一：软件生态

在特定领域的场景中，应用程序往往是定制化的，因此符合 posix 标准被认为足以兼容应用，但在以智能手机为代表的新兴场景中，很多应用和库以二进制形式分发，仅仅满足 posix 标准并不足以兼容，还要求 Linux ABI 兼容性。

#### 问题二：资源管理
在特定领域的场景中，应用程序较少，硬件资源优先，所以内核往往负责预留资源，应用程序自己管理，但在新兴场景中，多个应用程序竞争资源，因此需要内核有更完善的资源管理机制，实现高效而公平的资源管理和分配。

#### 问题三：性能

在特定领域的场景中，微内核优先考虑安全性和严格的资源隔离，并主要用于静态应用程序，性能不是关键点，但在新兴场景中，性能也是重中之重，因为性能直接决定用户体验并籍此影响内核的广泛部署。尽管 SOTA 微内核如 sel4 已经实现了破纪录的高 IPC 性能，但是他们仍会因为高频率的 IPC 、多服务端设计导致的状态双重簿记、基于能力的访问控制等问题造成不小的性能开销。

#### linux 的问题：

1. 安全可靠性不足。其文件系统和大量驱动贡献了大量 CVE 漏洞，并且其中 80% 的漏洞都可以通过正确的隔离解决，而且由于 linux 代码固有的紧密耦合，很难对其进行优化和重构。同时，内核模块的不稳定也导致了频繁的升级，使内核在实际部署中不太实用
2. 通用和专业化的冲突。linux 的目标是通用化，然而最新的 patch 在向服务器和云倾斜，甚至影响到了部分其他场景。同时，快速增长的各种设备需要专门的策略来保证性能和能耗，而对于 linux 进行针对性优化不仅需要消耗巨量人力，还很难并入内核主线。
3. 定制化和内核更新的冲突。定制化的内核和内核主线同步需要花费大量努力，而 linux 频繁更新的内核 API 更是阻碍了同步，这导致了实际部署内核时的内核定制化非常困难。因此，市面上大量产品仍在使用 linux 2.6，其生命周期早已结束。

### 针对问题的观察

由于鸿蒙早已广泛部署商用，所以收集了很多如手机、路由器、汽车等具有代表性的场景下的运行数据。

![Characteristics](../assets/figures/papers/micro-kernel/f1.png)

#### 观察一：新兴场景中 IPC 频率快速增加

当所有 OS 服务被限制在用户地址空间时，部分新兴场景下的 IPC 频率如图（1a）所示，智能手机（平均 41k/s）和车辆（平均 7k/s）的 IPC 频率远高于路由器（平均 0.6k/s，更接近领域特定场景），而从图（1b）（1e）（1f）中可以看出，更高的 IPC 频率不仅仅是因为更高的 syscall 频率（61k/s，路由器的 13 倍），还因为大量的文件操作（与文件系统的 IPC），以及在映射在内存上的文件上触发了大量的 page fault，这需要内存管理器和文件系统之间的大量 IPC。

**结论**：相比起提高 IPC 性能，减少 IPC 频率也很重要。

![flame_graph](../assets/figures/papers/micro-kernel/flame_graph.png)

#### 观察二：分布式多服务端导致状态双重簿记

在传统的宏内核设计中，所有服务包括文件系统、内存管理都在内核空间，页缓存、文件描述符等信息都作为全局变量由内核统一管理，仅需要维护一份；但在微内核架构的分布式多服务端设计中，文件系统服务和内存管理服务是隔离的，他们各自需要一份页缓存来加速文件访问/管理内存映射，并且两个服务都需要记录文件描述符，这就是状态双重簿记（state double bookkeeping）

微内核设计的最小化准则决定了共享资源（比如 fd 和页缓存）没有被集中化管理而是分布式存放，但是如图（1c）（1d）（1e）所示，新兴场景下的应用程序经常调用 poll 等函数，这些函数较为依赖对于这些共享资源的集中管理。图 2 进一步展示了应用程序启动的 CPU 火焰图，这对于文件映射的性能依赖很大，同时也对用户体验至关重要。如图所示， 16% 的时间倍用来处理页缓存未命中，比 linux 慢一倍，且状态双重簿记在文件系统和内存已经消耗了 120MB 的基础上额外消耗了 50MB 的内存。

#### 观察三：基于能力的访问控制阻碍了高效合作

基于能力的访问控制将内核对象隐藏在不同能力后面，这导致了某些内核对象的频繁更新（比如页表）从而引入了显著的性能开销，并阻碍了他们之间的高效合作，比如这可能会导致匿名页错误的处理比 linux 慢 3.4 倍，这种情况在智能手机中尤为常见（平均 27k/s，占图（1b）中的小型 page fault 的 80%），并且给应用程序增加了不小的启动开销时间（图 2 中的 4%）。

#### 观察四：生态兼容性要求不仅仅是符合 POSIX 标准

许多 SOTA 微内核通过使用自定义运行时库来实现 POSIX 合规的最小子集，这些库直接链接到应用长须，并生成 IPC 到系统服务，但是这样面临着二进制不兼容的问题以及需要一个自定义构建环境。此外，因为 Linux 使用文件作为统一的接口，而微内核内没有这样的接口，实现高效的 fd 复用以及向 ioctl 这样的向量系统调用变得很有挑战性，而这些系统调用在新兴场景非常常用（如图（1c-1e））

#### 观察五：新兴场景部署需要高效的驱动复用

在智能手机上部署鸿蒙时，我们发现所需的驱动数量大幅增加，对于路由器，所需的驱动少于 20 个，但是对于智能手机和车辆，则需要超过 700 个。我们估计重写这些驱动需要花费 5000 人/年，并且需要时间持续成熟和演化。所以，重用驱动是一个更明智的选择。然而，之前的工作，包括一直驱动的运行时环境和使用虚拟机等，面临着兼容性、工作量和性能方面的挑战。

### 鸿蒙的宏观设计

![design](../assets/figures/papers/micro-kernel/design.png)



